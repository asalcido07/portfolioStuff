{"changed":true,"filter":false,"title":"VirtualMachine.cpp","tooltip":"/VirtualMachine.cpp","value":"\n// Virtual Machine.cpp\n\n#include \"VirtualMachine.h\"\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <sstream>\n#include <map>\n#include <cstdint> // Added this on\n#include <vector>\n\nusing namespace std;\n\ninstruction ins;\n\nVirtualMachine::VirtualMachine()\n{\n    r = vector <int> (REG_FILE_SIZE);\n    mem = vector <int> (MEM_SIZE);\n    pc = ir = sr = base = clk = 0; // Changed limit to 10, which is the size of the instructions\n    flag = true;\n    sp = 256;\n\t\n\tinstructions[0] = &VirtualMachine::load_i; // Key values are like previous map\n\tinstructions[1] = &VirtualMachine::store;\n\tinstructions[2] = &VirtualMachine::add_i;\n\tinstructions[3] = &VirtualMachine::add_c_i;\n\tinstructions[4] = &VirtualMachine::sub_i;\n\tinstructions[5] = &VirtualMachine::sub_c_i;\n\tinstructions[6] = &VirtualMachine::and_i;\n\tinstructions[7] = &VirtualMachine::xor_i;\n\tinstructions[8] = &VirtualMachine::compl_;\n\tinstructions[9] = &VirtualMachine::shl;\n\tinstructions[10] = &VirtualMachine::shla;\n\tinstructions[11] = &VirtualMachine::shr;\n\tinstructions[12] = &VirtualMachine::shra;\n\tinstructions[13] = &VirtualMachine::compr_i;\n\tinstructions[14] = &VirtualMachine::get_stat;\n\tinstructions[15] = &VirtualMachine::put_stat;\n\tinstructions[16] = &VirtualMachine::jump;\n\tinstructions[17] = &VirtualMachine::jump_l;\n\tinstructions[18] = &VirtualMachine::jump_e;\n\tinstructions[19] = &VirtualMachine::jump_g;\n    instructions[20] = &VirtualMachine::call;\n    instructions[21] = &VirtualMachine::return_;\n    instructions[22] = &VirtualMachine::read;\n    instructions[23] = &VirtualMachine::write;\n    instructions[24] = &VirtualMachine::halt;\n    instructions[25] = &VirtualMachine::noop;\n} // VirtualMachine\n\nvoid VirtualMachine::read_file(fstream &object_code, fstream &input_file, fstream &output_file)\n{\n\t//Sets pointers to input/output file stream addresses (added 4/24 10:19 AM)\n\tinput = &input_file;\n\toutput = &output_file;\n\t\n\t//Loads instructions into memory\n\tint i;\n\tfor (i = base; i < mem.size() and !object_code.eof(); i++) \n\t\tobject_code >> mem[i];\n\t\n\tlimit = i; // Added this so limit is now the size of object code instructions\n\t\n\twhile (flag) {\n\t\tcout << \"Hey, I'm in the while loop right now!!!\" << endl;\n\t\tir = mem[pc++]; // Fetch is done here\n\t\tdecode();\n\t}\n\t\n\t(*output) << \"Total clock ticks: \" << clk << endl;\n\t\n} // read_file\n\nvoid VirtualMachine::decode()\n{\n\tins.i = ir; \n\t\n\tcout << \"OP: \" << ins.f1.OP << \"\\n\";\n\t\n\tif ((ins.f1.OP == 22) || (ins.f1.OP == 23)) {\n\t\tclk += 28;\n\t} else if (((ins.f2.OP == 0) && (ins.f2.I == 0)) || (ins.f1.OP == 1) || (ins.f1.OP == 20) || (ins.f1.OP == 21)) {\n\t\tclk += 4; \n\t} else {\n\t\tclk++;\n\t} // These conditions dont' take care of every case, have to look over\n\t  // Modified code to take care of every case possible at 12:24 AM  \n\t  // Conditions modified 4/24, 10:41 AM\n\t\n\t(this->*instructions[int(ins.f1.OP)])(); // Execute instruction\t\n\t\n\tcout << \"R0: \" << r[0] << \" R1: \" << r[1] << \" R2: \" << r[2] << \" R3: \" << r[3] << \" SR: \" << sr << \"\\n\";\n\t\n} // decode\n\t\t\t\t\t\t\t\t// load_i assigns a constant or address to a register based on the i bit\nvoid VirtualMachine::load_i()\n{\n    if (ins.f1.I == 1) {\t\t\n    \tr[ins.f3.RD] = ins.f3.CONST;\n    } else {\n    \tr[ins.f2.RD] = mem[ins.f2.ADDR];\n    \tcout << \"Executing load instruction...\" << endl;\n    } \n} // load_i\n\t\t\t\t\t\t\t\t// Store assigns the value from an address to memory\nvoid VirtualMachine::store()\n{\n    mem[ins.f2.ADDR] = r[ins.f2.RD];\n    cout << \"Storing the value \" << mem[ins.f2.ADDR] << endl;\n} // store\n\t\t\t\t\t\t\t// Addition is done based on i bit, in which either CONST or RS will be added with RD, carry will be set accordingly\nvoid VirtualMachine::add_i()\n{\n\tif (ins.f1.I == 1) {\n\t\toverflow_detect(r[ins.f3.RD], ins.f3.CONST, ins.f3.OP);\n\t\tr[ins.f3.RD] += ins.f3.CONST;\n\t\tcout << \"Executing ADD_I instruction...\" << endl;\n\t\tcout << \"New value in RD after addition is: \" << r[ins.f3.RD] << endl;\n\t\t\n\t} else {\n    \toverflow_detect(r[ins.f1.RD], r[ins.f1.RS], ins.f3.OP);\n    \tr[ins.f1.RD] += r[ins.f1.RS];\n\t}\n\t\n\t//Set carry bit\n\tif ((r[ins.f1.RD] & 1) == 0) {\n\t\tsr |= 1;\n\t} else {\n\t\tsr &= 0 << 1;\n\t}\n} // add_i\n\nvoid VirtualMachine::add_c_i() // Not sure how to do this one, needs carry\n{\n\tint carry = sr & 1;\n\t\n\tif (ins.f1.I == 1) {\n\t\toverflow_detect(r[ins.f3.RD], ins.f3.CONST+carry, ins.f3.OP);\n\t\tr[ins.f3.RD] = r[ins.f3.RD] + ins.f3.CONST + carry; // CARRY hasn't been defined yet, changed at 6:34 PM\n\t} else {\n\t\toverflow_detect(r[ins.f1.RD], r[ins.f1.RS] + carry, ins.f1.OP);\n\t\tr[ins.f1.RD] = r[ins.f1.RD] + r[ins.f1.RS] + carry; // changed at 6:34 PM\n\t}\n\t\n\tif ((r[ins.f1.RD] & 1) == 0) {\n\t\tsr |= 1;\n\t} else {\n\t\tsr &= 0 << 1;\n\t}\n} // add_c_i\n\t\t\t\t\t\t\t\t// Subtraction is done based on i bit, in which either CONST or RS will be added with RD, carry will be set accordingly\nvoid VirtualMachine::sub_i()\n{\n    if (ins.f3.I == 1) {\n    \tr[ins.f3.RD] = r[ins.f3.RD] - ins.f3.CONST; // Have to account for CARRY, changed at 6:36 PM\n    } else {\n    \tr[ins.f1.RD] = r[ins.f1.RD] - r[ins.f1.RS]; // have to set carry, changed at 6:36 PM\n    }\n    // running->sr.carry = (running->r[running->ir.rd] & 1);\n    if (r[ins.f1.RD] & 1) {\n    \tsr |= 1; \n    } else {\n\t\tsr &= 0 << 1;\n\t}\n} // sub_i\n\nvoid VirtualMachine::sub_c_i()\n{\n    int carry = sr & 1;\n    \n    if (ins.f1.I == 1) {\n    \tr[ins.f3.RD] = r[ins.f3.RD] - ins.f3.CONST - carry; // Have to set carry\n\t} else {\n\t\tr[ins.f1.RD] = r[ins.f1.RD] - r[ins.f1.RS] - carry;\n\t}\n\t\n\tif (r[ins.f1.RD] & 1) {\n    \tsr |= 1;\n\t} else {\n\t\tsr &= 0 << 1;\n\t}\n} // sub_c_i\n\t\t\t\t\t\t\t\t// Does and based on i bit and the value is assigned to the RD\nvoid VirtualMachine::and_i()\n{\n    if (ins.f1.I == 1) {\n    \tr[ins.f3.RD] &= ins.f3.CONST;\n    } else {\n    \tr[ins.f1.RD] &= r[ins.f1.RS];\n    }\n} // and_i\n\t\t\t\t\t\t\t\t// Does exclusive or based on i bit and the value is assigned to the RD\nvoid VirtualMachine::xor_i()\n{\n    if (ins.f1.I == 1) {\n    \tr[ins.f3.RD] ^= ins.f3.CONST;\n    } else {\n    \tr[ins.f1.RD] ^= r[ins.f1.RS];\n    }\n} // xor_i\n\t\t\t\t\t\t\t\t// Takes the complement of the value inside the RD\nvoid VirtualMachine::compl_()\n{\n    r[ins.f1.RD] = ~r[ins.f1.RD];\n} // compl_\n\t\t\t\t\t\t\t// Shifts value left 1 bit inside RD\nvoid VirtualMachine::shl()\n{\n\tint bit = (r[ins.f1.RD] >> 15) & 1;\n\tif (bit) {\n\t\tsr |= 1;\n\t} else {\n\t\tsr &= 0 << 1;\n\t}\n\t\n    r[ins.f1.RD] = r[ins.f1.RD] << 1; // Need to set carry\n} // shl\n\nvoid VirtualMachine::shla()\n{\n    int bit = (r[ins.f1.RD] >> 15) & 1; // Added this at 6:22 PM\n\tif (bit) {\n\t\tsr |= 1;\n\t} else {\n\t\tsr &= 0 << 1;\n\t}\n    r[ins.f1.RD] = (int16_t(r[ins.f1.RD])) << 1; // Added at 6:42 PM\n} // shla \n\t\t\t\t\t\t\t// Shifts value right 1 bit inside RD\nvoid VirtualMachine::shr()\n{\n\tbool bit = (r[ins.f1.RD] >> 0) & 1; // Added this at 6:20 PM, changed to look at the 0 bit\n\t\n\tcout << \"Bit: \" << bit << \"\\n\";\n\t\n\tif (bit) {\n\t\tsr |= 1; \n\t} else {\n\t\tsr &= 0 << 1;\n\t}\n    r[ins.f1.RD] = r[ins.f1.RD] >> 1; // Need to set carry bit\n} // shr\n\nvoid VirtualMachine::shra()\n{\n\tint bit = (r[ins.f1.RD] >> 0) & 1; // Added this at 6:22 PM, Changed to look at the 0 bit \n\tif (bit) {\n\t\tsr |= 1; \n\t} else {\n\t\tsr &= 0 << 1;\n\t}\n\tr[ins.f1.RD] = (int16_t(r[ins.f1.RD])) >> 1; // Added at 6:43 PM\n}  // shra\n\t\t\t\t\t\t\t\t// Based on i, RD will be either compared with RS or CONST and the equal, less,\nvoid VirtualMachine::compr_i()\t//  or greater bit is set and the others reset\n{\n    if (ins.f1.I == 1) {\n    \tif (r[ins.f3.RD] < ins.f3.CONST) {\n    \t\tsr |= 1 << 3;\n    \t\tsr &= ~(1 << 2);\n    \t\tsr &= ~(1 << 1);\n    \t} else if (r[ins.f3.RD] == ins.f3.CONST) {\n    \t\tsr |= 1 << 2;\n    \t\tsr &= ~(1 << 3);\n    \t\tsr &= ~(1 << 1);\n    \t} else if (r[ins.f3.RD] > ins.f3.CONST) {\n    \t\tsr |= 1 << 1;\n    \t\tsr &= ~(1 << 3);\n    \t\tsr &= ~(1 << 2);\n    \t}\n    \t\t\n    } else {\n    \tif (r[ins.f1.RD] < r[ins.f1.RS]) {\n    \t\tsr |= 1 << 3;\n    \t\tsr &= ~(1 << 2);\n    \t\tsr &= ~(1 << 1);\n    \t} else if (r[ins.f1.RD] == r[ins.f1.RS]) {\n    \t\tsr |= 1 << 2;\n    \t\tsr &= ~(1 << 3);\n    \t\tsr &= ~(1 << 1);\n    \t} else if (r[ins.f1.RD] > r[ins.f1.RS]) {\n    \t\tsr |= 1 << 1;\n    \t\tsr &= ~(1 << 3);\n    \t\tsr &= ~(1 << 2);\t\n    \t}\n    }\n} // compr_i\n\t\t\t\t\t\t\t\t// RD is assigned the value from sr \nvoid VirtualMachine::get_stat()\n{\n    r[ins.f1.RD] = sr;\n} // get_stat\n\t\t\t\t\t\t\t\t// sr is assigned the value from the RD\nvoid VirtualMachine::put_stat()\n{\n    sr = r[ins.f1.RD];\n} // put_stat\n\t\t\t\t\t\t\t// pc is assigned an address\nvoid VirtualMachine::jump()\n{\n    pc = ins.f2.ADDR;\n} // jump\n\t\t\t\t\t\t\t\t// Checks to see if less bit is set, if so pc is assigned an address, otherwise do nothing\nvoid VirtualMachine::jump_l()\n{\n    if ((sr >> 3) & 1) {\n    \tpc = ins.f2.ADDR;\n    }\n    \n} // jump_l\n\t\t\t\t\t\t\t\t// Checks to see if equal bit is set, if so pc is assigned an address, otherwise do nothing\nvoid VirtualMachine::jump_e()\n{\n    if ((sr >> 2) & 1) {\n    \tpc = ins.f2.ADDR;\n    }\n} // jump_e\n\t\t\t\t\t\t\t\t// Checks to see if greater bit is set, if so pc is assigned an address, otherwise do nothing\nvoid VirtualMachine::jump_g()\t\t\n{\n\tif ((sr >> 1) & 1)  {\n    \tpc = ins.f2.ADDR;\n    }\n} // jump_g\n\t\t\t\t\t\t\t// Stores address, puts registers, sr and pc in memory, sp is decremented accordingly\nvoid VirtualMachine::call()\n{\n\tcout << \"Inside call function...\" << endl;\n    \n    if (sp >= limit+6) {\n    \tfor (int i = 0; i < 4; i++) \n    \t\tmem[--sp] = r[i];\n    \t\n    \tmem[--sp] = sr;\n    \tmem[--sp] = pc;\n    \tpc = ins.f2.ADDR;\n    } else {\n    \tcout << \"Stack overflow! Program aborted.\\n\";\n    \texit(0);\n    }\n} // call\n\t\t\t\t\t\t\t\t// pc, rs, and registers are restored and sp is incremented accordingly\nvoid VirtualMachine::return_()\n{\n\tcout << \"Restoring PC and SR...\" << endl;\n\tpc = mem[sp++];\n\tsr = mem[sp++];\n\tfor (int i = 3; i != -1; i--) {\n\t\tr[i] = mem[sp++];\n\t\tcout << \"Restoring all registers...\" << endl;\n\t}\n} // return_\n\nvoid VirtualMachine::read()\n{\n\tcout << \"Reading from file...\" << endl;\n\t(*input) >> r[ins.f2.RD]; // Takes in value from fstream input and place it in a register\n} // read\n\nvoid VirtualMachine::write()\n{\n\tcout << \"Writing to file...\" << endl;\n\t(*output) << r[ins.f2.RD] << endl;\t// Writes out value inside register to fstream output\n} // write\n\nvoid VirtualMachine::halt()\n{\n    flag = false;\t// Assigned false to make the program stop running in the while loop of read_file\n    cout << \"HALT\\n\";\n} // halt\n\t\t\t\t\t\t\t// Nothing is done, besides print out a cout statement\nvoid VirtualMachine::noop()\n{\n    cout << \"NOOP\\n\";\n} // noop\n\nvoid VirtualMachine::overflow_detect(int first, int second, int OP) \n{\n\t//Overflow detection for addition\n\tif ((OP == 2) || (OP == 3)) {\n\t\t//Tests if two negative numbers make a positive number\n\t\tif (int16_t(first) < 0 && int16_t(second) < 0 && !(int16_t(first+second) & (1 << 15)))\n\t\t\tsr |= 0x10;\n\t\t//Tests if two positive numbers make a negative number\n\t\telse if (int16_t(first) > 0 && int16_t(second) > 0 && (int16_t(first+second) & (1 << 15)))\n\t\t\tsr |= 0x10;\n\t//Overflow detection for subtraction\n\t} else if ((OP == 4) || (OP == 5)) {\n\t\t//Tests if positive minus a negative makes a negative number\n\t\tif (int16_t(first) > 0 && int16_t(second) < 0 && (int16_t(first-second) & (1 << 15))) {\n\t\t\tsr |= 0x10;\n\t\t//Tests if negative minus a positive makes a positive number\n\t\t} else if (int16_t(first) < 0 && int16_t(second) > 0 && !(int16_t(first-second) & (1 << 15))) {\n\t\t\tsr |= 0x10;\n\t\t}\n\t}\n}\n","undoManager":{"mark":-2,"position":3,"stack":[[{"start":{"row":234,"column":29},"end":{"row":234,"column":30},"action":"remove","lines":["0"],"id":14272}],[{"start":{"row":234,"column":29},"end":{"row":234,"column":30},"action":"insert","lines":["1"],"id":14273}],[{"start":{"row":234,"column":29},"end":{"row":234,"column":30},"action":"remove","lines":["1"],"id":14274}],[{"start":{"row":234,"column":29},"end":{"row":234,"column":30},"action":"insert","lines":["0"],"id":14275}]]},"ace":{"folds":[],"scrolltop":0,"scrollleft":0,"selection":{"start":{"row":390,"column":37},"end":{"row":390,"column":37},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1461724321000}